// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

//
// begin JavaScript code
// AngularJS with a conjtroller in ES2015 class syntax
// and a pinch of jQuery for date pickers
//

// JS's Date objects are weak: only way to get YYYY-MM-DD string is to use toISOFormat() which fudges the time zone...
Date.prototype.YMD = function () {
    const y = 1900 + this.getYear();
    const m = 1 + this.getMonth();
    const d = this.getDate();
    return `${y}-${m >= 10 ? m : '0'+m}-${d}`;
};

// a function for calculating distance between two [lat, lng] tuples
function haversineDistance(latlng1, latlng2) {
    function toRad(x) {
        return x * Math.PI / 180;
    }

    const dLat = toRad(latlng2[0] - latlng1[0]);
    const dLon = toRad(latlng2[1] - latlng1[1]);
    const lat1 = toRad(latlng1[0]);
    const lat2 = toRad(latlng2[0]);

    //const R = 6371000; // meters
    const R = 3960; // miles

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// map JS Date weekday (0-6, 0=Sunday) to match our table values (Sun, Wed, Fri, etc)
const WEEKDAYS_LOOKUP = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', ];

// API key for Airtable
// USE A READ-ONLY USER because this could become visible to anyone who views the source
const AIRTABLE_API_KEY = "keymXIGCYEoPy4vib";

// the URL of the table
// which includes the account hash and URL-encoded table name
const AIRTABLE_SEARCH_URL = "https://api.airtable.com/v0/appv6KlqHiaOSlrcQ/All%20Services";

// the list of services offered for selection
// this MUST match the domain values in the Airtable
// DANGER! Airtable uses substring matching so one could get false matches,
// e.g. Health and Mental Health would both match "Health", and there would be no way to fetch only Health records (maybe some postprocessing?)
// so just don't do it! use distinct-enough values that substrings won't match
// sorry but that's the degree of Airtable's support for multiple-choice values
const SERVICES_OFFERED = [
    "Case Management",
    "Clothing/Blankets/Sleeping Bags",
    "Computer Access",
    "Drop In",
    "Food",
    "Health Care",
    "Housing",
    "Hygiene",
    "Legal",
    "Mail",
    "Mental Health",
    "Phone",
    "Referrals",
    "Restroom",
    "Substance Abuse",
];

// the controller class and then launch
class PageController {
    // match this argument list to the $inject list provided below... or weird things will happen
    constructor($scope, $http, $window, $timeout) {
        // injections we want to pass into other methods (sigh)
        this.$scope = $scope;
        this.$http = $http;
        this.$timeout = $timeout;

        // cache some dates used for calendar date picker and date buttons
        // used for a minimum date allowed, as well as "is the selected date tomorrow?"
        this.today = new Date();

        this.tomorrow = new Date();
        this.tomorrow.setDate(this.tomorrow.getDate() + 1);

        // initial search-and-results state
        this.search = {
            // search params: date and services
            services: [],
            date: null,
            // search results and having in fact ever performed a search
            results: [],
            done: false,
        };
        // application state stuff
        this.busy    = false;       // are we busy?
        this.showmap = false;       // should we be showing results the map? if not, then the list

        // assign some constants into scope so we can use them to build the UI
        this.services_list = SERVICES_OFFERED;

        // start watching our location: null for unknown, or [ lat, lng ]
        // we use this to update a marker on the map, and to sort the list by what's closest
        this.geolocation = [ 0, 0 ];
        navigator.geolocation.watchPosition(
            (position) => {
                $scope.$evalAsync(() => {
                    this.geolocation = [ parseFloat(position.coords.latitude), parseFloat(position.coords.longitude) ];
                });
            },
            (error) => {
              console.warn(`Geolocation: ${err.message}`);
            },
            {
                enableHighAccuracy: true,
            }
        );

        $scope.$watchCollection(() => this.geolocation, this.updateGeolocationResultsList(), true);
        $scope.$watchCollection(() => this.geolocation, this.updateGeolocationMapmarker(), true);

        // start the map
        this.resultsmap = new google.maps.Map(document.getElementById('resultsmap'), {
            center: new google.maps.LatLng(0, 0),
            zoom: 16,
            mapTypeId: google.maps.MapTypeId.TERRAIN,
            scrollwheel: false,
            fullscreenControl: false,
            streetViewControl: false,
            zoomControlOptions: {
                position: google.maps.ControlPosition.TOP_RIGHT,
            },
            mapTypeControlOptions: {
                position: google.maps.ControlPosition.TOP_RIGHT,
                mapTypeIds: [google.maps.MapTypeId.TERRAIN, google.maps.MapTypeId.HYBRID ]
            }
        });

        google.maps.event.addListenerOnce(this.resultsmap, 'idle', function() {
            this.mapTypes[google.maps.MapTypeId.HYBRID].name = 'Photo'; // hack to rename the layer's name in the control
        });

        this.resultsmap.youarehere = new google.maps.Marker({
            position: { lat: 0, lng: 0 },
            title: "You Are Here",
            icon: 'images/youarehere.gif',
        });

        this.resultsmap.locations = [];
        $scope.$watch(() => this.search.results, this.redrawLocationMarkers(), true);

        // map custom controls: zoom to my location, zoom to region, Mapbox + OSM credits
        function makeCustomControl(controlDiv, map) {}

        var controlDiv1 = document.getElementById('GeolocationControl');
        var newControl1 = new makeCustomControl(controlDiv1, this.map);
        this.resultsmap.controls[google.maps.ControlPosition.RIGHT_TOP].push(controlDiv1);

        // add map workarounds: they hate being invisible and malfunction strangely
        // tell GMap that its size has changed (even though it has not)
        angular.element($window).on('resize', () => {
            if (! this.showmap) return;

            $timeout(() => {
                google.maps.event.trigger(this.resultsmap, 'resize');
                this.resultsmap.setCenter( this.resultsmap.getCenter() );
            }, 100);
        });

        $scope.$watch(() => this.showmap, () => {
            if (this.showmap) {
                angular.element($window).triggerHandler('resize');
            }
        });

        // watch the resultdetails to see if we are opening the panel
        // client wants it contrived to match to the bottom-left of the Google Map
        angular.element($window).on('resize', () => {
            if (! this.showmap) return;
            this.fixDetailPanelPosition();
        });
        $scope.$watch(() => this.resultdetails, () => {
            if (! this.showmap) return;
            $timeout(() => {
                this.fixDetailPanelPosition();
            }, 100);
        }, true);
    }

    openDatePicker () {
        $('#modal_datepicker').modal('show');
    }
    closeDatePicker () {
        $('#modal_datepicker').modal('hide');
    }
    pickDate (which) {
        // accepts a named day (today or tomorrow) or "date" to pick one
        switch (which) {
            case 'today':
                this.search.date = this.today;
                break;
            case 'tomorrow':
                this.search.date = this.tomorrow;
                break;
            case 'date':
                this.openDatePicker(); // has a change handler which will set search.date
                break;
            case 'clear':
                this.search.date = null;
                break;
        }
    }

    performSearch () {
        // check required
        if (! this.search.services.length) return alert("Select the help you are trying to find.");
        if (! this.search.date) return alert("Select a date.");

        // compose the filter formula
        // the syntax is weird, and the documentation is quite poor, but here's a start...
        // https://support.airtable.com/hc/en-us/articles/203255215-Formula-Field-Reference
        // super brief overviews of some gotchas:
        // * syntax for a giant and is: AND( clause1, clause2, clause3, ...)
        // * field names with spaces should be wrapped in {}
        // * there is no IN operator for arrays, just substring matching; see the note in SERVICES_OFFERED about overlapping substrings
        let formula = [];

        const weekday = WEEKDAYS_LOOKUP[this.search.date.getDay()];
        formula.push(`FIND("${weekday}", Day) > 0`);

        this.search.services.forEach(function (wanted) {
            formula.push(`FIND("${wanted}", {Services Offered}) > 0`);
        });

        formula = `AND(${formula.join(", ")})`;

        // compose the query and send it off
        var params = {
            filterByFormula: formula,
        };

        this.busy = true;
        this.$http({
            method: 'GET',
            url: AIRTABLE_SEARCH_URL,
            params: params,
            headers: {
                "Authorization": `Bearer ${AIRTABLE_API_KEY}`
            },
        })
        .then(
            (response) => {
                this.busy = false;
                this.search.results = response.data.records.map(item => {
                    // extract the fields, then do some data corrections
                    // many of the fields come out as arrays of strings, instead of single values
                    item.fields.Address     = item.fields.Address[0];
                    item.fields.AgencyName  = item.fields.AgencyName[0];
                    item.fields.LatLng      = item.fields.lat && item.fields.lng ? [ parseFloat(item.fields.lat[0]), parseFloat(item.fields.lng[0]) ] : null; // can be empty!

                    // new synthetic field: DistanceMiles from your location; to be filled in afterward, declared here for clarity + documentation
                    item.fields.DistanceMiles = null;

                    // new synthetic field: Start and End times, prettier version for rendering
                    item.fields.StartTime = item.fields['Start Hour'] ? `${item.fields['Start Hour'] >= '10' ? item.fields['Start Hour']: item.fields['Start Hour'].substr(1)}:${item.fields['Start Minute']} ${item.fields['Start AM-PM']}` : '';
                    item.fields.EndTime   = item.fields['End Hour'] ? `${item.fields['End Hour'] >= '10' ? item.fields['End Hour'] : item.fields['End Hour'].substr(1)}:${item.fields['End Minute']} ${item.fields['End AM-PM']}` : '';

                    return item.fields;
                });

                // add distance decorators and sort by distance from me; note the wrapped nature here
                this.updateGeolocationResultsList()();

                // center the map on our own location
                this.resultsmap.setCenter({ lat: this.geolocation[0], lng: this.geolocation[1] });
                this.resultsmap.setZoom(14);

                // we have now performed a search; results or no, it's done
                this.search.done = true;
            },
            (error) => {
                this.busy = false;
                alert("Could not connect to the site. Check your connection and try again.");
            }
        );
    }

    updateGeolocationMapmarker () {
        // wrapped function for use with $watch
        return () => {
            // update the You Are Here map marker and recenter
            if (this.resultsmap) {
                this.resultsmap.youarehere.setPosition({ lat: this.geolocation[0], lng: this.geolocation[1] });
                this.resultsmap.youarehere.setMap(this.resultsmap);
            }
        };
    }

    updateGeolocationResultsList () {
        // wrapped function for use with $watch
        return () => {
            // tag each result with its distance from my geolocation
            // then sort the list so closest locations come first
            this.search.results.forEach(item => {
                item.DistanceMiles = (item.LatLng && this.geolocation) ? haversineDistance(this.geolocation, item.LatLng) : null;
            });

            this.search.results.sort((p, q) => {
                if (p.DistanceMiles === null) return 1; // no location = send to the end of the list
                if (q.DistanceMiles === null) return -1; // no location = send to the end of the list
                return p.DistanceMiles > q.DistanceMiles ? 1 : -1;
            });
        };
    }

    redrawLocationMarkers () {
        // wrapped function for use with $watch
        return () => {
            // empty current markers
            this.resultsmap.locations.forEach(marker => {
                marker.setMap(null);
            });
            this.resultsmap.locations = [];

            // load the new ones
            this.search.results.forEach(item => {
                if (! item.LatLng) return; // some lack a location

                const marker = new google.maps.Marker({
                    position: { lat: item.LatLng[0], lng: item.LatLng[1] },
                    title: item.AgencyName,
                    map: this.resultsmap,
                    details: item, // the raw attribute details
                });

                this.resultsmap.locations.push(marker);

                google.maps.event.addListener(marker, 'click', () => {
                    this.$scope.$evalAsync(() => {
                        this.resultdetails = marker.details;
                    });
                });
            });
        };
    }

    searchBack () {
        // empty our results and done flag so we go back to the search panel
        // but don't modify their search parameters
        this.search.done = false;
        this.search.results = [];
    }

    zoomMapToGeolocation () {
        if (! this.geolocation) return alert("Still searching for location.");
        this.zoomMapToLatLng(this.geolocation);
    }

    zoomMapToLatLng (latlng, switchtomap) {
        const doit = () => {
            this.resultsmap.setCenter({ lat: latlng[0], lng: latlng[1] });
            this.resultsmap.setZoom(16);
        };

        if (switchtomap && ! this.showmap) {
            this.showmap = true;
            this.$timeout(doit, 500);
        }
        else {
            doit();
        }
    }

    fixDetailPanelPosition () {
        const mapdiv = angular.element( $('#resultsmap') )[0];
        const top    = mapdiv.offsetTop + mapdiv.offsetHeight - 100; // fixed number = height of the DIV in CSS, so bottom matches bottom
        const left   = mapdiv.offsetLeft; // no idea why the extra 10 is needed
        const width  = mapdiv.offsetWidth;
        this.resultdetails_position = { top: top+'px', left: left+'px', width: width+'px' };
    }
}

PageController.$inject = [ '$scope', '$http', '$window', '$timeout' ];

angular.module('app', [
    'checklist-model',
    'ui.bootstrap',
])
.controller('PageController', PageController);
